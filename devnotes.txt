process: 	
	client1 http to server.js ->

	client1's main.js creates a variable 'room', a random string created via randomToken(); ->

	client1  main.js emits 'create or join' with room variable as parameter ->

	server.js' socket.on for 'create or join' sets numClients variable to how many clients are in the room (io.sockets.clients(room)) ->
		
	client1 will socket.join(room), and emit a 'created' event with the room and socket.id as parameters. ->

	back in main.js, client1's socket.on handler for 'created' sets isInitiator empty variable to true, and calls grabWebCamVideo, which is a function of getUserMedia with constraints video and audio true, and both success and error callbacks -> NEXT

	client2 http to server.js ->

	client2's main.s grabs the URL hash given by client1 and sets the variable room to it ->

	client2's main.js emits 'create or join' with room variable as parameter ->

	server.js' socket.on for 'create or join' sees that the number of clients in the room is already 1 (given that client1 is still connected to the websocket), and accordingly client2 joins the room, emits a 'joined' event and a 'ready' event ->

	main.js handles the join event by console logging the client ID and room, setting isInitiator to false, and grabbing the webcam video, but we don't end here like for client1, now we continue to the 'ready' handler ->

	the socket.on handler for 'ready' calls createPeerConnection with isInitiator (most likely false as is from client2) and configuration (ice server URL) as parameters. ->

	createPeerConnection creates variable peerConn as a new RTCPeerConnection(config) object. RTCPeerConnection is the WebRTC component that handles stable and efficient communication of streaming data between peers. The important thing is that RTCPeerConnection shields web developers from the myriad complexities that lurk beneath. For example, the following are abstracted over by WebRTC:

		packet loss concealment
		echo cancellation
		bandwith adaptivity
		dynamic jitter buffering
		automatic gain control
		noise reduction and suppression
		image 'cleaning' ->

	{
		peerConn calls createOffer if isInitiator is true, which creates a data channel. client2 will respond with an answer. Both offer and answer are handled in the signalingMessageCallback which checks the message.type. if it's an offer (client2 receiving offer from client1), or answer, the method will call setRemoteDescription() which changes the remote description associated with the connection. If the message is an offer, then peerConn will call createAnswer on the localSessionCreated (this is abstracted, don't worry) ->

		Even though the browsers know about each other, they still can't connect due to router NATs which gives you a private IP address that is local to your network and invisible from the public internet -> STUN 

		peerConn sends an asynchronous call to onicecandidate, a function that sends an ice candidate with sendMessage, which is a function that socket.emits a message to server.js with all candidate information ->

		this again calls signalingMessageCallback, but this time the 'candidate' case is called, and peerConn calls addIceCandidate, which sends an ice candidate across to the other peer via the API (abstracted). this will cause the other peer to send back a message and execute signalingMessageCallback and send over their own ice candidate. ->

		peer to peer engaged!
	}
data channel:
	dataChannel is set to peerCon.createDataChannel for arbitrary type name "media" ->

	onDataChannelCreated is called, logging the channel, calling channel.open, and detecting which browser dependent factory to use

	for photos, snapPhoto() calls photoContext's (photo.getContext('2d')) drawImage, which calls show(). ->

	sendPhoto() defines a chunk length to be 64kb, divides the photo's data into pieces 64kb long, and sends them piece by piece over the data channel using dataChannel.send(img.data.subarray(start, end))




















